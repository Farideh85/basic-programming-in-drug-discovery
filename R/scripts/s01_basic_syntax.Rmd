---
title: "basic syntax"
output: 
  
  html_notebook:
    theme: united
    toc: yes
  html_document:
    toc: yes
editor_options: 
  chunk_output_type: inline
---

Note: to run the lines, select them or locate the cursor on a specific line and hold the `ctrl` key while typing `enter`  

## Basic math operations, classes and variables        
### basic math operations    

We can perform calculations on numerical objects
```{r}
1 + 1
```

```{r}
1 - 1
```

```{r}
1 / 1
```

```{r}
1 * 1
```

### classes  

To find out what class an object is you can use the `class()` function  
```{r}
class(1)
```

Another class is the so called `string` or `character` type,  
you let R know you want to define a character class by using single or double quotes:  
```{r}
class("1")
```

* exercise: Run the line, why did you get an error?   
Can you fix this error? 
```{r}
13 + "5"  
```

The `+` is an example of a binary operator. Basically a function that can take 2 input arguments and return a single output.  
However, we will look into functions later today. The `non-numeric` argument refers to the 5 not being numeric. It is called an `argument` because it is the input to the binary operator.  

Another important class in R is the `factor`. Factors allow ordering of descriptors/ nominal variables. Many R functions treat factors differently compared to the character class. It is important to be aware if your data is stored as character vs factor.  
The default in R is to store all character data as factor. You can turn this default behavior off with `options(stringsAsFactors = FALSE)`. When we look at the data object class `data.frames` we will have a look at some examples involving factors.  



## data storage objects  
There are several objects in R that handle data storage. We will go through them one by one.   
But first the concept of placeholders, also called identifiers, has to be explained.  

You, as a programmer, are expected to create logical placeholder names. These names should be short, but still clarify what it is. Placeholders are used to store any object type. It is recommended to:  
* separate words with underscores: my_variable.  
* use small letters  
* for functions use verbs: join_tables()  


### placeholders  
As an example of a placeholder, let us define a variable that enables us to store a time-stamp:  
```{r}
current_time <- Sys.time()
current_time  
```
Run the lines several times, see how the placeholder `current_time` stores the output of our `Sys.time()` function?  
We can also store the output of a calculation:  

```{r}
my_result <- 5 * (1+5)
my_result
```
And use this later on in our analysis, because it is stored in `R memory`! 
```{r}
my_result + 1
```

* exercise: explain and then fix the error message you get when running the following line of code: 
```{r}
my_other_result + 1  
```




### vectors
A vector object is created with the `c()` command, each entry is separated by a comma:  
`my_vector <- c( 4, 6, 2, 4, 1)`   


* exercise: Now that we know how to create vectors, how to create variables and strings/ characters lets practice this:  
Create a vector with the `c()` function containing the sentence, "hello, my name is " in the first entry and in the second vector entry a placeholder containing your name.  Make sure to define the placeholder containing your name first, or you will get an error!   
```{r}

```


Another way to create sequences of numbers is with the `seq()` function. Have a look at the help file for `seq' by typing
?seq  
Note the `from` `to` `by` and `length.out` arguments. To create a sequence of 6 equally spaced numbers from 0 to 10 you can do:
`my_seq <- seq(from = 0, to = 10, by = 2)` or you can do `my_seq <- seq(from = 0, to = 10, length.out = 6)` 
Another useful method to generate sequences of integers is the colon: `1:10`  

* exercise: Try all three methods to generate a sequence of numbers from 12 to 2 with steps of 1. 
```{r}

```


It is also possible to do calculations with numeric vectors. There is a behavior to be aware of called recycling. 
* exercise: Calculate the sum of these vectors and explain recycling:  `1:6 + 1:2` also try `1:5` + `1:2`, when and why did you get a warning?   
```{r}

```

Now let us move on to selection operations on vectors. Square brackets `[]` are used for selection. Selection by dimension (rows/columns/ or 3d) can be performed by separating the arguments inside the brackets by comma's. A vector however, has only 1 dimension. To select the second entry of my_seq: `my_seq[2]` 
exercise: Select entry 1, 3 and 5 of `my_seq`:  
```{r}

```

### matrixes  
Single class tables can be stored as matrices. Matrices are not so useful for us biologists, but super useful for fast matrix calculations in the for of linear algebra needed for the various statistical tools available in R.  We will have a quick look at them. To define a matrix:  
```{r}
my_matrix <- matrix(1:9, nrow = 3, ncol = 3)
my_matrix
my_matrix2 <- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
my_matrix2
```
Selection of matrix data is two dimensional, you need row and column identifiers, selection occurs like this: 
`my_matrix[`*row-numbers*`,` *column-numbers*`]` to select row 2 and 3 of the 1st and 3rd columns:  

```{r}
my_matrix[2:3, c(1, 3)]  
```


### data.frames  
The data.frame allows mixing data classes, so you can mix numeric, strings and factors. Let's have a look at the already available `iris` data.frame using the `head` function to display only the first 7 rows.   
```{r}
head(iris, n = 7)
```
To define your own data frame use the `data.frame()` function:  
```{r}
my_dataframe <- data.frame(names = c("Steven", "Margriet", "Gerard", "Elke"),
                           hobbies = c("R", "Python", "cheminformatics", "pharmacokinetics"),
                           sex = c("M", "F", "M", "F"),
                           fakeage = c(38, 30, 34, 28))
my_dataframe
```


The column classes are already displayed under the column names (if you have a recent version of R Studio installed). An alternative to inspect the column classes is to check them manually, for column one and five this would be:  
```{r}
class(iris[, 1])
class(iris[, 5])
```
This mixing of data types is not possible in matrices.  
Before we dive deeper into `data.frames`, we will discuss the `factor` class. Let us print the contents of the `Species` column from the `iris` `data.frame`:  
```{r}
iris[, 5]
```
Note the `Levels` at the bottom? This informs us this column has the class `factor`, and also informs us of the unique factor levels. This is mainly important for statistical analysis, where defining the order is important. However many functions and visualization tools in R also use the factor data type to define for example the order of displaying data labels or the order of plotting nominal values on the x-axis.  
You can create the `factor` class with (first we transform the `Species` to character class): 
```{r}
iris$Species <- as.character(iris$Species)
iris$Species
iris$Species <- factor(iris$Species)
iris$Species
```
 Always think of `data.frames` in a column-wise fashion. A column represents a variable. Next to `iris[, 5]` We can aces `data.frame` columns with `iris$Species` or `iris[, "Species"]`  

This is an opportune moment to explain Boolean and conditional selection. The Boolean class, in R called the logical class, is another class of data. It has the values `TRUE`, `FALSE` and `NA`. The `NA` is used if the entry does not exist.  
With logicals it is possible to perform selection. For example;  
`iris[ iris$Petal.Length < 1.4,  ]` displays all rows of the `iris` data for which the Petal Length is smaller than 1.4.  
printing the `iris$Petal.Length < 1.4` statement clearly shows what is happening.  
```{r}
iris$Petal.Length < 1.4
```
It is possible to perform multiple conditional selections by using the `&` sign in between.  

* exercise: Display the `Petal.Length` for all plants that belong to the virginica Species.  
```{r}

```


* exercise: Display the `Petal.Length` for all plants that belong to the virginica species for which the petal length is smaller than 1.6.    
```{r}

```

Finally, we will have a quick look how we can perform calculations with data frames. To define a new variable (thus column) in your data frame you can use direct assignment to a new variable: `iris$is_small_Sepal <- iris$Sepal.Length < 5 | iris$Sepal.Width < 3`   
Now note that you can do calculations on Boolean
```{r}
sum(c(TRUE, TRUE, FALSE, FALSE, TRUE))
```
* exercise: how many small sepal plants are there for each of the three species? With small as defined above.  
```{r}

```

Note how we used multiple columns in a `data.frame` to calculate a new column and that these operations are performed row-wise, thus for each plant!  

### lists  

Lists are another object class in R to store data. Actually any object can be stored in lists, for example functions, data frames, vectors, characters and even other lists can all be placed in a list. If you put 1 object in a list, the list has length 1, putting 2 objects in the list creates a list of length 2, and so on. You can name the entries in the list making access easy and explicit. Let's create a list with named entries:  
```{r}
my_list <- list(teachers = my_dataframe, stat = t.test( 
  subset(iris, Species == "virginica")[, "Sepal.Length"], subset(iris, Species == "setosa")[, "Sepal.Length"]) )

my_list

```

To access an entry in our list there are several options. One can use the name:  
```{r}
my_list$teachers
my_list$stat
```
Or simply index numbers:  
```{r}
my_list[[1]]
```
If you want to keep the list attributes use a single bracket:  
```{r}
my_list[1]
```
To select multiple slots simultaneously use single brackets:  
```{r}
my_list[1:2]
```

Accessing objects inside lists is also straightforward, access the list entry and then treat the object selections as you would normally:  
```{r}
my_list$teachers$hobbies
```
Or you could do:  
```{r}
my_list[[1]][, "hobbies"]
```

* exercise: Store the iris data frame as and additional slot in the existing list object `my_list`  
```{r}

```

* exercise: Display the `Sepal.Lengths` of all `virginca` and `setosa` plants from within the `my_list`  
```{r}

```



To conclude, lists are a usefull addition to data frames because they are more flexible.  


### arrays  
Arrays are higher dimensional  matrixes. For example, a three dimensional array can be thought of as multiple matrixes stacked behind one another, for 4 3x3 matrixes:    
```{r}
my_array <- array(1:28, dim = c(3, 3, 4))
dim(my_array)
my_array
```

To access 2nd row, 2nd column of 2nd matrix: [row, column, extra_dimension1]  
```{r}
my_array[ 2, 2, 2 ]
```
Or to access the 3rd matrix:  
```{r}
my_array[ , , 3]
```

But you could also give the matrices themselves indexes in multiple dimensions, for example:  
```{r}
my_array <- array(1:28, dim = c(3, 3, 2, 2 ))
dim(my_array)
my_array
```



## control flow and repetition  
Next to one time diving into data for analysis, it is often useful to create automated workflows, your own packages or even pieces of software. In these cases it is useful to learn a little bit more than loading and accessing data, so we will dive into a bit more advanced programming tools, such as control flow and repetition. These concepts are often also useful even for interactive data analysis.  

### conditionals

Conditionals make your program perform an action depending on the input. To do this the `if else` syntax is used. 
The basic syntax is:  `if(TRUE) { do this }`  
For example;  
```{r}
sepal_size <- 6
if( sepal_size < 5 ) { # note the opening curly braces  
  sepal_class <- "small"
} # note the matching closing curly braces  
```

* exercise: run the lines above, what is sepal_class now? Does it exist? Why (not)?  

So the `if` statement above was evaluated as `FALSE` and the lines between the curly braces were skipped. Would'nt it be nice to define sepal_class as `large` without creating another separate `if` statement? Rejoice, we can!  

```{r}
sepal_size <- 6
if( sepal_size < 5 ) { 
  sepal_class <- "small"
} else {
  sepal_class <- "large"
}
```


It is even possible to create as many `else if` conditionals as you like:  
```{r}
sepal_size <- 6
if( sepal_size < 5 ) { 
  sepal_class <- "small"
} else if( sepal_size > 8) {
  sepal_class <- "large"
} else {
  sepal_class <- "medium"
}
```
* exercise: without running the code above, what does `sepal_class` evaluate to?  

* exercise: modify the example above to include another interval between 5 and 6 that evaluates to `medium-small`  

### for loops
Coding would be alot less useful if we could not be able to repeat operations easily. For repetition R uses the following loop syntax: `for(i in 1:10)`{ code to repeat in here }.  The `i` can be anything, and the number of repetitions can be to your choosing as well. In this example we perform 10 repetitions with the sequence of numbers from 1 to 10. Take note the variable `i` will evaluate to each of these numbers in the sequence. This is usefull for indexing as will become clear in the following example:  
```{r}

```


### functional programming: apply family  


## functions 


## data reshaping and summarization  


###
###
###



## data visualization  

### base plotting methods  

method dispatch 


### ggplot2 



## read and write  



## packages, CRAN & Bioconductor  

